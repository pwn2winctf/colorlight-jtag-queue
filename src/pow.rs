use crate::hashcash::{HashcashError, Token};
use bloomfilter::Bloom;
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use hmac::{Hmac, Mac, NewMac};
use serde::{Deserialize, Serialize};
use sha3::Sha3_256;
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::{io::Cursor, time::SystemTime};
use thiserror::Error;

const TIMEOUT: u64 = 60;
const DIFFICULTY: u32 = 28;
const SECRET_KEY: &[u8] = b"qs6zfWbtDRezb7AE4W1QON16jAKraZ5U";

const BITMAP_BYTES_PER_SEC: usize = 16;
const EXPECT_ITEMS_PER_SEC: usize = 32;

#[derive(Error, Debug)]
pub enum PoWError {
    #[error("token not generated by this server")]
    InvalidToken,
    #[error("token expired since epoch {0}")]
    ExpiredToken(u64),
    #[error("token already spent")]
    DoubleSpend,
    #[error("hashcash error: {0}")]
    HashcashError(#[from] HashcashError),
    #[error("rwlock error")]
    RwLockError,
}

fn time() -> u64 {
    SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap()
        .as_secs()
}

type HmacSha3_256 = Hmac<Sha3_256>;

#[derive(Debug, Clone)]
pub struct PoWManager {
    pub spent_tokens: Arc<RwLock<HashMap<u64, Bloom<String>>>>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct PoWToken {
    expiration: u64,
    command: String,
}

impl PoWManager {
    pub fn new() -> Self {
        PoWManager {
            spent_tokens: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub fn get_token(&self) -> Result<PoWToken, PoWError> {
        let expiration = time() + TIMEOUT;
        let mut buf = vec![];
        buf.write_u64::<LittleEndian>(expiration).unwrap();
        let mut mac = HmacSha3_256::new_from_slice(SECRET_KEY).unwrap();
        mac.update(buf.as_slice());
        buf.extend(mac.finalize().into_bytes());
        return Ok(PoWToken {
            expiration,
            command: format!(
                "hashcash -Cmb{} {}",
                DIFFICULTY,
                base64::encode_config(buf, base64::URL_SAFE)
            ),
        });
    }

    pub fn validate_token(&self, token: &str) -> Result<(), PoWError> {
        // Validate hashcash PoW
        let tk = Token::from_str(token)?;
        if tk.bits != DIFFICULTY {
            return Err(PoWError::InvalidToken);
        }
        tk.check()?;
        let remounted_token = tk.to_string();

        // Validate resource was generated by this server and is not expired
        let buf = base64::decode_config(&tk.resource, base64::URL_SAFE)
            .or(Err(PoWError::InvalidToken))?;
        let (data, tag) = buf.as_slice().split_at(8);
        let mut rdr = Cursor::new(data);
        let expiration = rdr
            .read_u64::<LittleEndian>()
            .or(Err(PoWError::InvalidToken))?;
        let ts = time();
        if ts > expiration {
            return Err(PoWError::ExpiredToken(expiration));
        }
        if expiration >= ts + TIMEOUT {
            return Err(PoWError::InvalidToken);
        }
        let mut mac = HmacSha3_256::new_from_slice(SECRET_KEY).unwrap();
        mac.update(data);
        mac.verify(tag).or(Err(PoWError::InvalidToken))?;

        // Validate token is not double spent
        let mut tokens = self.spent_tokens.write().or(Err(PoWError::RwLockError))?;
        let bloom = tokens
            .entry(expiration)
            .or_insert(Bloom::new(BITMAP_BYTES_PER_SEC, EXPECT_ITEMS_PER_SEC));
        let exists_bloom = bloom.check(&remounted_token);
        bloom.set(&remounted_token);

        // collect garbage
        let expired_keys: Vec<u64> = tokens
            .iter()
            .filter(|&(&k, _)| k < ts)
            .map(|(&k, _)| k)
            .collect();
        for k in expired_keys {
            tokens.remove(&k);
        }

        if exists_bloom {
            return Err(PoWError::DoubleSpend);
        }

        Ok(())
    }
}
